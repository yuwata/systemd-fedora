From c93a24119977a11791aab0f3df5e5cb9973a34de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Sat, 11 May 2024 13:27:12 +0200
Subject: [PATCH] Revert "machined: add varlink interface for registering
 machines"

This reverts commit 5b44c81ff868a4d1b78a74e4770f7a8b2f1d0f91.
---
 man/systemd-machined.service.xml        |  6 +--
 src/machine/machine-varlink.h           |  6 ---
 src/machine/machined-varlink.c          | 62 ++-----------------------
 src/machine/machined.c                  |  5 +-
 src/machine/machined.h                  |  3 +-
 src/machine/meson.build                 |  1 -
 src/shared/meson.build                  |  1 -
 src/shared/varlink-io.systemd.Machine.h |  6 ---
 8 files changed, 8 insertions(+), 82 deletions(-)
 delete mode 100644 src/machine/machine-varlink.h
 delete mode 100644 src/shared/varlink-io.systemd.Machine.h

diff --git a/man/systemd-machined.service.xml b/man/systemd-machined.service.xml
index b2899ff0fd..f3d7755973 100644
--- a/man/systemd-machined.service.xml
+++ b/man/systemd-machined.service.xml
@@ -100,12 +100,10 @@
 
     <para>The daemon provides both a C library interface
     (which is shared with <citerefentry><refentrytitle>systemd-logind.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>)
-    as well as a D-Bus interface and a Varlink interface.
+    as well as a D-Bus interface.
     The library interface may be used to introspect and watch the state of virtual machines/containers.
     The bus interface provides the same but in addition may also be used to register or terminate
-    machines. The Varlink interface may be used to register machines with optional extensions, e.g. with an
-    SSH key / address; it can be queried with
-    <command>varlinkctl introspect /run/systemd/machine/io.systemd.Machine io.systemd.Machine</command>.
+    machines.
     For more information please consult
     <citerefentry><refentrytitle>sd-login</refentrytitle><manvolnum>3</manvolnum></citerefentry>
     and
diff --git a/src/machine/machine-varlink.h b/src/machine/machine-varlink.h
deleted file mode 100644
index ce4ec54dc1..0000000000
--- a/src/machine/machine-varlink.h
+++ /dev/null
@@ -1,6 +0,0 @@
-/* SPDX-License-Identifier: LGPL-2.1-or-later */
-#pragma once
-
-#include "varlink.h"
-
-int vl_method_register(Varlink *link, JsonVariant *parameters, VarlinkMethodFlags flags, void *userdata);
diff --git a/src/machine/machined-varlink.c b/src/machine/machined-varlink.c
index 0d3ae627c1..6ca98e27cf 100644
--- a/src/machine/machined-varlink.c
+++ b/src/machine/machined-varlink.c
@@ -1,12 +1,10 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include "format-util.h"
-#include "machine-varlink.h"
 #include "machined-varlink.h"
 #include "mkdir.h"
 #include "user-util.h"
 #include "varlink.h"
-#include "varlink-io.systemd.Machine.h"
 #include "varlink-io.systemd.UserDatabase.h"
 
 typedef struct LookupParameters {
@@ -380,13 +378,13 @@ static int vl_method_get_memberships(Varlink *link, JsonVariant *parameters, Var
         return varlink_error(link, "io.systemd.UserDatabase.NoRecordFound", NULL);
 }
 
-static int manager_varlink_init_userdb(Manager *m) {
+int manager_varlink_init(Manager *m) {
         _cleanup_(varlink_server_unrefp) VarlinkServer *s = NULL;
         int r;
 
         assert(m);
 
-        if (m->varlink_userdb_server)
+        if (m->varlink_server)
                 return 0;
 
         r = varlink_server_new(&s, VARLINK_SERVER_ACCOUNT_UID|VARLINK_SERVER_INHERIT_USERDATA);
@@ -417,64 +415,12 @@ static int manager_varlink_init_userdb(Manager *m) {
         if (r < 0)
                 return log_error_errno(r, "Failed to attach varlink connection to event loop: %m");
 
-        m->varlink_userdb_server = TAKE_PTR(s);
-        return 0;
-}
-
-static int manager_varlink_init_machine(Manager *m) {
-        _cleanup_(varlink_server_unrefp) VarlinkServer *s = NULL;
-        int r;
-
-        assert(m);
-
-        if (m->varlink_machine_server)
-                return 0;
-
-        r = varlink_server_new(&s, VARLINK_SERVER_ROOT_ONLY|VARLINK_SERVER_INHERIT_USERDATA);
-        if (r < 0)
-                return log_error_errno(r, "Failed to allocate varlink server object: %m");
-
-        varlink_server_set_userdata(s, m);
-
-        r = varlink_server_add_interface(s, &vl_interface_io_systemd_Machine);
-        if (r < 0)
-                return log_error_errno(r, "Failed to add UserDatabase interface to varlink server: %m");
-
-        r = varlink_server_bind_method(s, "io.systemd.Machine.Register", vl_method_register);
-        if (r < 0)
-                return log_error_errno(r, "Failed to register varlink methods: %m");
-
-        (void) mkdir_p("/run/systemd/machine", 0755);
-
-        r = varlink_server_listen_address(s, "/run/systemd/machine/io.systemd.Machine", 0666);
-        if (r < 0)
-                return log_error_errno(r, "Failed to bind to varlink socket: %m");
-
-        r = varlink_server_attach_event(s, m->event, SD_EVENT_PRIORITY_NORMAL);
-        if (r < 0)
-                return log_error_errno(r, "Failed to attach varlink connection to event loop: %m");
-
-        m->varlink_machine_server = TAKE_PTR(s);
-        return 0;
-}
-
-int manager_varlink_init(Manager *m) {
-        int r;
-
-        r = manager_varlink_init_userdb(m);
-        if (r < 0)
-                return r;
-
-        r = manager_varlink_init_machine(m);
-        if (r < 0)
-                return r;
-
+        m->varlink_server = TAKE_PTR(s);
         return 0;
 }
 
 void manager_varlink_done(Manager *m) {
         assert(m);
 
-        m->varlink_userdb_server = varlink_server_unref(m->varlink_userdb_server);
-        m->varlink_machine_server = varlink_server_unref(m->varlink_machine_server);
+        m->varlink_server = varlink_server_unref(m->varlink_server);
 }
diff --git a/src/machine/machined.c b/src/machine/machined.c
index d7087e4672..2638ed572e 100644
--- a/src/machine/machined.c
+++ b/src/machine/machined.c
@@ -316,10 +316,7 @@ static bool check_idle(void *userdata) {
         if (m->operations)
                 return false;
 
-        if (varlink_server_current_connections(m->varlink_userdb_server) > 0)
-                return false;
-
-        if (varlink_server_current_connections(m->varlink_machine_server) > 0)
+        if (varlink_server_current_connections(m->varlink_server) > 0)
                 return false;
 
         manager_gc(m, true);
diff --git a/src/machine/machined.h b/src/machine/machined.h
index 67abed0fd6..280c32bab6 100644
--- a/src/machine/machined.h
+++ b/src/machine/machined.h
@@ -40,8 +40,7 @@ struct Manager {
         sd_event_source *nscd_cache_flush_event;
 #endif
 
-        VarlinkServer *varlink_userdb_server;
-        VarlinkServer *varlink_machine_server;
+        VarlinkServer *varlink_server;
 };
 
 int manager_add_machine(Manager *m, const char *name, Machine **_machine);
diff --git a/src/machine/meson.build b/src/machine/meson.build
index 3150b33de5..c82a32589d 100644
--- a/src/machine/meson.build
+++ b/src/machine/meson.build
@@ -3,7 +3,6 @@
 libmachine_core_sources = files(
         'image-dbus.c',
         'machine-dbus.c',
-        'machine-varlink.c',
         'machine.c',
         'machined-core.c',
         'machined-dbus.c',
diff --git a/src/shared/meson.build b/src/shared/meson.build
index d01367a159..17313aefed 100644
--- a/src/shared/meson.build
+++ b/src/shared/meson.build
@@ -180,7 +180,6 @@ shared_sources = files(
         'varlink-io.systemd.Credentials.c',
         'varlink-io.systemd.Hostname.c',
         'varlink-io.systemd.Journal.c',
-        'varlink-io.systemd.Machine.c',
         'varlink-io.systemd.ManagedOOM.c',
         'varlink-io.systemd.MountFileSystem.c',
         'varlink-io.systemd.NamespaceResource.c',
diff --git a/src/shared/varlink-io.systemd.Machine.h b/src/shared/varlink-io.systemd.Machine.h
deleted file mode 100644
index c9fc85f150..0000000000
--- a/src/shared/varlink-io.systemd.Machine.h
+++ /dev/null
@@ -1,6 +0,0 @@
-/* SPDX-License-Identifier: LGPL-2.1-or-later */
-#pragma once
-
-#include "varlink-idl.h"
-
-extern const VarlinkInterface vl_interface_io_systemd_Machine;
