From adb0b43649d48ef3ff6e72be52f916fc98aaea3e Mon Sep 17 00:00:00 2001
From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Tue, 26 Jan 2021 16:12:41 +0900
Subject: [PATCH] log: skip to read the kernel command line if the process is
 invoked by a script

CLI tools may be used in a script. E.g., a script for monitoring a
service may use `systemctl`. Previously, if the kernel command line has
e.g. systemd.log-level=debug, then systemctl in the script produces
debugging logs when the script is invoked by a .service unit, but does
not when the script is running in a terminal. Then,
https://github.com/systemd/systemd/pull/18281#discussion_r561697482,
> I expect users to be (negatively) surprised.

In the previous commit, $SYSTEMD_EXEC_PID= is introduced. Then, we can
now detect whether a command is directly invoked by systemd or through
a script. Let's skip to parse the kernel command line when a command is
invoked through a script.
---
 src/basic/log.c | 29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

diff --git a/src/basic/log.c b/src/basic/log.c
index f2cd1c3041..2899dcd5c5 100644
--- a/src/basic/log.c
+++ b/src/basic/log.c
@@ -1157,15 +1157,36 @@ static int parse_proc_cmdline_item(const char *key, const char *value, void *dat
         return 0;
 }
 
+static bool should_parse_proc_cmdline(void) {
+        const char *e;
+
+        /* PID1 always reads the kernel command line. */
+        if (getpid_cached() == 1)
+                return true;
+
+        /* If the process is directly executed through a unit, then reads the command line.
+         * If it is invoked by a script executed in a unit, then skip to read the command line. */
+        e = getenv("SYSTEMD_EXEC_PID");
+        if (e) {
+                pid_t p;
+
+                if (parse_pid(e, &p) >= 0)
+                        return getpid_cached() == p;
+                else
+                        log_warning("Failed to parse $SYSTEMD_EXEC_PID=%s. Ignoring.", e);
+        }
+
+        /* Assume that anything that has a controlling tty is user stuff. In that case, skip to read
+         * the command line. */
+        return get_ctty_devnr(0, NULL) < 0;
+}
+
 void log_parse_environment(void) {
         const char *e;
 
         /* Do not call from library code. */
 
-        if (getpid_cached() == 1 || get_ctty_devnr(0, NULL) < 0)
-                /* Only try to read the command line in daemons. We assume that anything that has a
-                 * controlling tty is user stuff. For PID1 we do a special check in case it hasn't
-                 * closed the console yet. */
+        if (should_parse_proc_cmdline())
                 (void) proc_cmdline_parse(parse_proc_cmdline_item, NULL, PROC_CMDLINE_STRIP_RD_PREFIX);
 
         e = getenv("SYSTEMD_LOG_TARGET");
