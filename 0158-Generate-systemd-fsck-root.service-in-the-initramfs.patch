From 754ba6bd338a15a698a3152e8fbecbc20d09afec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Wed, 6 May 2015 01:09:53 -0400
Subject: [PATCH] Generate systemd-fsck-root.service in the initramfs

In the initrafms, generate a systemd-fsck-root.service to replace
systemd-fsck@<sysroot-device>.service. This way, after we transition
to the real root, systemd-fsck-root.service is marked as already done.

This introduces an unnecessary synchronization point, because
systemd-fsck@* is ordered after systemd-fsck-root also in the
initramfs. In practice this shouldn't be a problem.

https://bugzilla.redhat.com/show_bug.cgi?id=1201979

C.f. 956eaf2b8d6c9999024705ddadc7393bc707de02.

(cherry picked from commit 4dda4e637e4c17a14db6cd265f36f5e8a5050367)
---
 src/shared/generator.c | 63 ++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 59 insertions(+), 4 deletions(-)

diff --git a/src/shared/generator.c b/src/shared/generator.c
index cd37812f86..148a0b077b 100644
--- a/src/shared/generator.c
+++ b/src/shared/generator.c
@@ -29,8 +29,51 @@
 #include "generator.h"
 #include "path-util.h"
 #include "fstab-util.h"
+#include "fileio.h"
 #include "dropin.h"
 
+static int write_fsck_sysroot_service(const char *dir, const char *what) {
+        const char *unit;
+        _cleanup_free_ char *device = NULL;
+        _cleanup_fclose_ FILE *f = NULL;
+
+        unit = strjoina(dir, "/systemd-fsck-root.service");
+        log_debug("Creating %s", unit);
+
+        device = unit_name_from_path(what, ".device");
+        if (!device)
+                return log_oom();
+
+        f = fopen(unit, "wxe");
+        if (!f)
+                return log_error_errno(errno, "Failed to create unit file %s: %m", unit);
+
+        fprintf(f,
+                "# Automatically generated by %1$s\n\n"
+                "[Unit]\n"
+                "Documentation=man:systemd-fsck-root.service(8)\n"
+                "Description=File System Check on %2$s\n"
+                "DefaultDependencies=no\n"
+                "BindsTo=%3$s\n"
+                "After=%3$s\n"
+                "Before=shutdown.target\n"
+                "\n"
+                "[Service]\n"
+                "Type=oneshot\n"
+                "RemainAfterExit=yes\n"
+                "ExecStart=/usr/lib/systemd/systemd-fsck %2$s\n"
+                "TimeoutSec=0\n",
+                program_invocation_short_name,
+                what,
+                device);
+
+        fflush(f);
+        if (ferror(f))
+                return log_error_errno(errno, "Failed to write unit file %s: %m", unit);
+
+        return 0;
+}
+
 int generator_write_fsck_deps(
                 FILE *f,
                 const char *dir,
@@ -69,11 +112,23 @@ int generator_write_fsck_deps(
                         return log_error_errno(errno, "Failed to create symlink %s: %m", lnk);
 
         } else {
-                _cleanup_free_ char *fsck = NULL;
+                _cleanup_free_ char *_fsck = NULL;
+                const char *fsck;
+                int r;
+
+                if (in_initrd() && path_equal(where, "/sysroot")) {
+                        r = write_fsck_sysroot_service(dir, what);
+                        if (r < 0)
+                                return r;
+
+                        fsck = "systemd-fsck-root.service";
+                } else {
+                        _fsck = unit_name_from_path_instance("systemd-fsck", what, ".service");
+                        if (!_fsck)
+                                return log_oom();
 
-                fsck = unit_name_from_path_instance("systemd-fsck", what, ".service");
-                if (!fsck)
-                        return log_oom();
+                        fsck = _fsck;
+                }
 
                 fprintf(f,
                         "RequiresOverridable=%1$s\n"
